  ../  			1
  source  			17
source/  DataStructures  			0
source/  FileBuilder  .hpp			0
source/  FileParser  .hpp			0
source/  FileParserComments  .hpp			0
source/  FileParserComments  .ut.hpp			0
source/  FileParserComments  .ut.cpp			0
source/  FileParserKeyWords  .hpp			0
source/  FileParserSyntax  .hpp			0
source/  GeneratorTxt  .hpp			0
source/  Program  .hpp			0
source/  ProjectTreeBuilder  .hpp			0
source/  ProjectTreeParser  .hpp			0
source/  Tools  			0
source/  catch_main  .cpp			0
source/  main  .cpp			0
source/  dataStructures  			7
source/dataStructures/  BaseStructures  			0
source/dataStructures/  DataWithSyntax  .hpp			0
source/dataStructures/  FileHeader  .hpp			0
source/dataStructures/  ParsedFile  .hpp			0
source/dataStructures/  PathInitializer  .ut.cpp			0
source/dataStructures/  PathInitializer  .ut.hpp			0
source/dataStructures/  PathInitializer  .hpp			0
source/  tools  			4
source/tools/  Converter  .hpp			0
source/tools/  FileIO  .hpp			0
source/tools/  IgnoreFiles  .cpp			0
source/tools/  IgnoreFiles  .hpp			0



############################################################################  ../





############################################################################



############################################################################  source





############################################################################



############################################################################  source/DataStructures
string
vector

dataStructures/BaseStructures
dataStructures/FileHeader.hpp
dataStructures/ParsedFile.hpp
dataStructures/PathInitializer.hpp




############################################################################
#pragma once
//#include "dataStructures/DataWithSyntax.hpp"
namespace DataStructures {
using Data = BaseStructures::Data;
using Line = BaseStructures::Line;
//using SyntaxedData = std::vector<DataWithSyntax>;
using ProjectTree = std::vector<FileHeader>;
using ParsedProjectTree = std::vector<ParsedFile>;
}



############################################################################  source/FileBuilder.hpp
string

Tools
dataStructures/FileHeader.hpp




############################################################################
#pragma once
class FileBuilder {
using IgnoreFiles = Tools::IgnoreFiles;
const std::string path_;
const std::string name_;
const std::string format_;
const FileHeader product_;
public:
explicit FileBuilder(
const std::string& path,
const std::string& fullName,
const std::vector<FileHeader>& subfiles, int depth):
path_(AppendConditionalSlash(path)),
name_(CutoutName(fullName)),
format_(CutoutFormat(fullName)),
product_(BuildProduct(subfiles, depth))
{}
std::string getDefaultPath() const { return "../"; }
FileHeader getProduct() const { return product_; }
protected:
FileHeader BuildProduct(const std::vector<FileHeader>& subFiles, int depth) {
return FileHeader(name_, path_, format_, subFiles, depth);
}
std::string CutoutName(const std::string& str) const {
if (Tools::IgnoreFiles::isIgnored(str)) {
return str;
}
auto index = str.find('.', 1);
if (index == std::string::npos) {
return str;
}
index = str.size() - index;
std::string result;
result.insert(result.begin(), str.begin(), str.end()-index);
return result;
}
std::string CutoutFormat(const std::string& str) const {
if (Tools::IgnoreFiles::isIgnored(str)) {
return "";
}
auto index = str.find('.', 1);
if (index == std::string::npos) {
return "";
}
std::string result;
result.insert(result.begin(), str.begin()+index, str.end());
return result;
}
std::string AppendConditionalSlash(std::string str) const {
if (!str.empty()) {
str += (str.at(str.size()-1) == '/')? "" : "/";
}
return str;
}
};



############################################################################  source/FileParser.hpp

DataStructures
Tools
FileParserComments.hpp
FileParserSyntax.hpp




############################################################################
#pragma once
class FileParser {
using Data = DataStructures::Data;
const std::string initPath_;
const FileHeader rawFile_;
const ParsedFile product_;
public:
FileParser(const std::string& initPath, const FileHeader& file):
initPath_(initPath),
rawFile_(file),
product_(BuildProduct())
{}
ParsedFile getProduct() const { return product_; }
private:
ParsedFile BuildProduct() const {
auto data = Tools::FileIO::readFile(initPath_ + rawFile_.getFile());
data = FileParserComments::modifyData(data);
auto includes = CutoutIncludes(data);
// SyntaxedData syntaxedData_;
// syntaxedData = FileParserSyntax::generateSyntax(data);
// return ParsedFile(rawFile_, data, syntaxedData, includes);
return ParsedFile(rawFile_, data, includes);
}
std::vector<std::string> CutoutIncludes(Data& data) const {
std::vector<std::string> includes;
for (auto& line : data) {
if (Tools::Converter::removeWhitespaces(line)[0] != '#') {
continue;
}
if (line.find("#include") != std::string::npos) {
includes.push_back(line.substr(8));
line = "";
}
}
return includes;
}
};



############################################################################  source/FileParserComments.hpp

DataStructures




############################################################################
#pragma once
/* TODO:
- fix multiline comments
ex: abcd *//* */ /* *** */ /* */ /* abcdc */
class FileParserComments {
protected:
using Data = DataStructures::Data;
using Line = DataStructures::Line;
FileParserComments() {}
public:
static Data modifyData(Data data) {
RemoveAllOnelineComments(data);
RemoveMultilineComments(data);
return data;
}
protected:
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
static Data RemoveAllOnelineComments(Data data) {
for (auto& line : data) {
line = RemoveOnelineComments(line);
}
return data;
}
static Line RemoveOnelineComments(const Line& line) {
auto i = line.find("//");
if (i == std::string::npos) {
return line;
}
if (IsInsideString(line.substr(0, i))) {
return line;
}
return line.substr(0, i);
}
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
static Data RemoveMultilineComments(Data data) {
bool isCommented = false;
for (auto& line : data) {
if (isCommented) {
Multiline_ClearLine(line, isCommented);
}
auto begin = line.find("/*");
if (begin != std::string::npos) {
Multiline_FindClosing(line, isCommented, begin);
}
}
return data;
}
static Line Multiline_ClearLine(Line line, bool& isCommented) {
auto end = line.find("*/");
if (end == std::string::npos) {
return "";
}
if (IsAlreadyCommentedByOneline(line.substr(0, end))) {
return "";
}
if (IsInsideString(line.substr(0, end))) {
return "";
}
isCommented = false;
return line.substr(end + 2);
}
static Line Multiline_FindClosing(Line line, bool& isCommented, const size_t begin) {
auto end = line.find("*/", begin);
if (end != std::string::npos) {
std::string tmp = line.substr(end + 2);
return line.substr(0, begin) + " " + tmp;
}
isCommented = true;
return line.substr(0, begin);
}
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
static bool IsInsideString(const Line& subline) {
auto count_a = std::count(subline.begin(), subline.end(), '\"');
auto count_b = std::count(subline.begin(), subline.end(), '\'');
return (count_a % 2) || (count_b % 2);
}
static bool IsAlreadyCommentedByOneline(const Line& subline) {
return (subline.find("//") != std::string::npos);
}
};



############################################################################  source/FileParserComments.ut.hpp

FileParserComments.hpp




############################################################################
class FileParserComments_UnitTest : FileParserComments {
public:
FileParserComments_UnitTest() {}
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
bool IsInsideString(const Line& line) {
return FileParserComments::IsInsideString(line);
}
bool IsAlreadyCommentedByOneline(const Line& subline) {
return FileParserComments::IsAlreadyCommentedByOneline(subline);
}
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
Line RemoveOnelineComments(const Line& line) {
return FileParserComments::RemoveOnelineComments(line);
}
Data RemoveAllOnelineComments(const Data& data) {
return FileParserComments::RemoveAllOnelineComments(data);
}
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
Line Multiline_ClearLine(const Line& line, bool& isCommented) {
return FileParserComments::Multiline_ClearLine(line, isCommented);
}
};



############################################################################  source/FileParserComments.ut.cpp
algorithm
numeric

plugins/catch.hpp
FileParserComments.ut.hpp




############################################################################
FileParserComments_UnitTest testObject;
TEST_CASE("FileParserComments: base operations", "[IsInsideString], [IsAlreadyCommentedByOneline]") {
struct test {
const std::string line_;
const bool expectedValue_;
std::string log() const {
return
"{ \"" + line_
+ "\" == " + std::to_string(expectedValue_)
+ " }";
}
};
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
WHEN("Testing the IsInsideString()") {
const std::initializer_list<test> tests = {
{ "", false },
{ " abcd", false },
{ "abcd", false },
{ " \" a\"bcd", false },
{ " \' a\'bcd", false },
{ " \" \"\" a\"bcd", false },
{ " \' \'\' a\'bcd", false },
{ " \" \'\' a\"bcd", false },
{ " \' \"\" a\'bcd", false },
{ " \" \'\" a\'bcd", false },
{ " \' \"\' a\"bcd", false },
{ " \"\" a\'bcd", true },
{ " \'\' a\"bcd", true },
{ " \" a\'bcd", true },
{ " \' a\"bcd", true },
{ " \" abcd", true },
{ " \' abcd", true },
{ "\"\" \" abcd", true },
{ "\'\' ww \' abcd", true }
};
for (const auto& test : tests) {
THEN(test.log()) {
REQUIRE_NOTHROW(testObject.IsInsideString(test.line_));
auto result = testObject.IsInsideString(test.line_);
REQUIRE(result == test.expectedValue_);
}
}
}
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
WHEN("Testing the IsAlreadyCommentedByOneline()") {
const std::initializer_list<test> tests = {
{ "", false },
{ "/", false },
{ " abcd", false },
{ "abcd", false },
{ "//", true },
{ " abcd//", true },
{ " ab//cd", true },
{ " // abcd", true },
{ "// abcd", true },
{ " // abcd//", true },
{ " / abcd//", true },
{ " / a/bcd//", true },
{ "// / abcd", true },
{ "// / a/b/c/d", true },
{ " / abcd", false },
{ "/ / a/bc/d", false },
};
for (const auto& test : tests) {
THEN(test.log()) {
REQUIRE_NOTHROW(testObject.IsAlreadyCommentedByOneline(test.line_));
auto result = testObject.IsAlreadyCommentedByOneline(test.line_);
REQUIRE(result == test.expectedValue_);
}
}
}
}
TEST_CASE("FileParserComments: RemoveOneLine operations", "[RemoveOnelineComments], [RemoveAllOnelineComments]") {
struct test {
const std::string line_;
const std::string expectedValue_;
std::string log() const {
return
"{ \"" + line_
+ "\" == \"" + expectedValue_
+ "\" }";
}
};
const std::initializer_list<test> tests = {
{"", ""},
{" abcd", " abcd"},
{" // abcd", " "},
{" a//bcd", " a"},
{" abcd//", " abcd"},
{"// abcd", ""},
{" /abcd", " /abcd"},
{" /a/b/cd", " /a/b/cd"},
{" abcd/", " abcd/"},
{"/ abcd", "/ abcd"},
{"/ abcd/", "/ abcd/"},
{" \" abcd", " \" abcd"},
{" \" abcd\"", " \" abcd\""},
{" \"\" abcd", " \"\" abcd"},
{" \' abcd", " \' abcd"},
{" \' abcd\'", " \' abcd\'"},
{" \'\' abcd", " \'\' abcd"},
{" \"\' abcd", " \"\' abcd"},
{" \"\'\" abcd", " \"\'\" abcd"},
{" \" //abcd", " \" //abcd"},
{" \" abcd\"//", " \" abcd\""},
{" \"\"// abcd", " \"\""},
{" //\' abcd", " "},
{" \' a/bcd\'", " \' a/bcd\'"},
{" \'\' abc//d", " \'\' abc"},
{" \"\' a//bcd", " \"\' a//bcd"},
{" \"\'\" a//bcd", " \"\'\" a//bcd"},
{" \"\' a/bcd", " \"\' a/bcd"},
{" \"\'\" a/bcd", " \"\'\" a/bcd"}
};
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
WHEN("Testing the RemoveOnelineComments()") {
for (const auto& test : tests) {
THEN(test.log()) {
REQUIRE_NOTHROW(testObject.RemoveOnelineComments(test.line_));
auto result = testObject.RemoveOnelineComments(test.line_);
REQUIRE(result == test.expectedValue_);
}
}
}
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
WHEN("Testing the RemoveAllOnelineComments()") {
std::vector<std::string> data;
data.reserve(tests.size());
std::for_each(tests.begin(), tests.end(), [&](auto test){ data.push_back(test.line_); });
REQUIRE_NOTHROW(testObject.RemoveAllOnelineComments(data));
auto results = testObject.RemoveAllOnelineComments(data);
size_t i = 0;
for (const auto& test : tests) {
THEN("id: " + std::to_string(i) + " (" + results.at(i) + ") == (" + test.expectedValue_ + ")") {
REQUIRE(results.at(i) == test.expectedValue_);
}
++i;
}
}
}
TEST_CASE("FileParserComments: RemoveMultiline operations", "[ClearLine]") {
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
WHEN("Testing the Multiline_ClearLine()") {
struct test {
const std::string line_;
const std::string expectedValue_;
const bool expectedBool_;
std::string log() const {
return
"{ \"" + line_
+ "\" == \"" + expectedValue_
+ "\" }";
}
};
const std::initializer_list<test> tests = {
{"", "", true},
{"asdfbd", "", true},
{"asdfbd*/", "", false},
{"asd*/fbd", "fbd", false},
{"*/asdfbd", "asdfbd", false},
{"*/asdfbd*/", "asdfbd*/", false},
{"asd*/fbd*/", "fbd*/", false},
{"asd*/*/fbd*/", "*/fbd*/", false},
{"asd/*/fbd*/", "fbd*/", false},
{"asd//fbd*/", "", true},
{"//asd*/fbd", "", true},
{"asd//*/fbd*/", "", true},
{"asd*///fbd*/", "//fbd*/", false},
{"asd*/f//bd*/", "f//bd*/", false},
{"a/s/d/*/fbd", "fbd", false},
{"a/s/d*/fbd", "fbd", false},
{"asd*/fb\"d", "fb\"d", false},
{"asd*/fb\"\"d", "fb\"\"d", false},
{"asd*/fb\'d\'", "fb\'d\'", false},
{"a\"sd*/fb\"d", "", true},
{"a\'sd*/fb\"d", "", true},
{"a\"s\"d*/fb\"d", "fb\"d", false},
{"a\'s\'d*/fb\"d", "fb\"d", false},
{"a\"s\'d*/fb\"d", "", true},
{"a\'s\"d*/fb\"d", "", true}
};
for (const auto& test : tests) {
THEN(test.log()) {
bool isCommented = true;
REQUIRE_NOTHROW(testObject.Multiline_ClearLine(test.line_, isCommented));
isCommented = true;
auto result = testObject.Multiline_ClearLine(test.line_, isCommented);
REQUIRE(result == test.expectedValue_);
REQUIRE(isCommented == test.expectedBool_);
}
}
}
}



############################################################################  source/FileParserKeyWords.hpp





############################################################################



############################################################################  source/FileParserSyntax.hpp
map

DataStructures




############################################################################
#pragma once
/*
class FileParserSyntax {
protected:
using Data = DataStructures::Data;
using Line = DataStructures::Line;
using SyntaxedData = DataStructures::SyntaxedData;
FileParserSyntax() {}
public:
static SyntaxedData generateSyntax(const Data& data) {
return Generate(data);
}
protected:
static SyntaxedData Generate(const Data& data) {
SyntaxedData result;
std::string spareLines;
for (const auto& line : data) {
if (HasSemicolon(line)) {
result.push_back({"instruction", spareLines + line});
spareLines = CutoutSpareLines(line);
}
else {
spareLines += line + "\n";
}
}
return result;
}
static bool HasSemicolon(const Line& line) {
return (line.find(';') != std::string::npos);
}
static Line CutoutSpareLines(const Line& line) {
const auto i = line.find(';');
return (i < line.size() - 1)? line.substr(i) : "";
}
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
static std::map<size_t, char> CreateTagMap(const Data& data) {
std::map<size_t, char> result;
for (size_t i = 0; i < data.size(); ++i) {
auto open = data[i].find("{");
auto close = data[i].find("}");
auto key = GenerateKey(open, close);
if (key != 'n') {
result[i] = key;
}
}
return result;
}
static char GenerateKey(const size_t open, const size_t close) {
if (open == std::string::npos) {
if (close == std::string::npos) {
return 'n'; // none
}
return 'c'; // close
}
if (close == std::string::npos) {
return 'o'; // open
}
return 'b'; // both
}
};
*/



############################################################################  source/GeneratorTxt.hpp
sstream

Tools
DataStructures




############################################################################
#pragma once
class GeneratorTxt {
using ParsedProjectTree = DataStructures::ParsedProjectTree; // std::vector<ParsedFile>;
const std::string initPath_;
const ParsedProjectTree data_;
public:
explicit GeneratorTxt(const std::string& initPath, const ParsedProjectTree& data):
initPath_(initPath),
data_(data)
{}
std::string buildFile() {
std::stringstream result;
for (const auto& file : data_) {
result << file.getPath() << " ";
result << file.getName() << " ";
result << file.getFormat() << "\t\t\t";
result << std::to_string(file.getSubFiles().size()) << "\n";
}
for (const auto& file : data_) {
result << "\n\n\n############################################################################ ";
result << file.getFile() << "\n";
result << Tools::Converter::to_string(file.getLibIncludes()) << "\n";
result << Tools::Converter::to_string(file.getProjIncludes()) << "\n";
result << "\n\n\n############################################################################\n";
result << file.getData();
}
return result.str();
}
};



############################################################################  source/Program.hpp
iostream

DataStructures
Tools
ProjectTreeBuilder.hpp
ProjectTreeParser.hpp
GeneratorTxt.hpp




############################################################################
#pragma once
class Program {
const std::string targetPath_;
const std::string outputPath_;
// ProjectTree rawData_;
public:
explicit Program(const std::string& target):
targetPath_(target),
outputPath_("sup.txt")
// rawData_()
{}
void execute() {
initializeIgnoreFiles();
ProjectTreeBuilder builder(targetPath_);
auto rawData_ = builder.getProduct();
ProjectTreeParser parser(targetPath_, rawData_);
auto parsedData = parser.getProduct();
for (const auto& file : parsedData) {
std::cout
<< file.depth_ << "\t"
<< file.getPath() << "\t\t"
<< file.getName() << "\t\t"
<< file.getFormat() << "\t\t" << file.getSubFiles().size() << "\n";
//std::cout << file.path_ << " " << file.name_ << " " << file.format_ << "\n";
//std::cout << file.path_ << file.name_ << file.format_ << "\n";
}
GeneratorTxt generator(targetPath_, parsedData);
Tools::FileIO::saveToFile(outputPath_, generator.buildFile());
}
private:
void initializeIgnoreFiles() {
using Tools::Converter;
using Tools::FileIO;
using Tools::IgnoreFiles;
auto fileName = IgnoreFiles::getIgnoreFileName();
if (FileIO::fileExist(fileName)) {
auto data = FileIO::readFile(fileName);
data = IgnoreFiles::pickoutAlwaysIgnored(data);
IgnoreFiles::setIgnoreFiles(Converter::to_set(data));
}
else {
auto data = IgnoreFiles::getDefaultIgnoreFiles();
FileIO::saveToFile(fileName, Converter::to_fileData(data));
}
}
};



############################################################################  source/ProjectTreeBuilder.hpp
algorithm
string

DataStructures
Tools
FileBuilder.hpp




############################################################################
#pragma once
class ProjectTreeBuilder {
using ProjectTree = DataStructures::ProjectTree;
const std::string initPath_;
const ProjectTree product_;
public:
explicit ProjectTreeBuilder(const std::string& initPath):
initPath_(initPath),
product_(BuildProduct())
{}
ProjectTree getProduct() const { return product_; }
private:
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
ProjectTree BuildProduct() const {
auto project = BuildProductStructure();
return project;
}
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
ProjectTree BuildProductStructure() const {
auto subFiles = BuildRecursive("", 1);
FileHeader root(initPath_, subFiles);
return FlatenRecursive(root);
}
std::vector<FileHeader> BuildRecursive(const std::string& targetPath, int depth) const {
auto paths = Tools::FileIO::readPaths(initPath_ + targetPath);
std::vector<FileHeader> files;
for (const auto& path : paths) {
auto subFiles = BuildRecursive(targetPath + path + '/', depth + 1);
FileBuilder builder(targetPath, path, subFiles, depth);
files.push_back(builder.getProduct());
}
std::sort(files.begin(), files.end(), SortCriterion_CatalogLast);
return files;
}
ProjectTree FlatenRecursive(const FileHeader& root) const {
ProjectTree result;
result.push_back(root);
for (const auto& file : root.getSubFiles()) {
auto subResult = FlatenRecursive(file);
result.insert(result.end(), subResult.begin(), subResult.end());
}
return result;
}
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
static bool SortCriterion_CatalogLast(const FileHeader& f, const FileHeader& s) {
int test = f.isCatalog() + s.isCatalog();
if (test % 2 == 0) {
return SortCriterion_Alphabetical(f.getName(), s.getName());
}
else {
return s.isCatalog();
}
}
static bool SortCriterion_Alphabetical(const std::string& f, const std::string& s) {
return (f < s);
}
};



############################################################################  source/ProjectTreeParser.hpp
algorithm
string

DataStructures
Tools
FileParser.hpp




############################################################################
#pragma once
//#include "PathInitializer.hpp"
class ProjectTreeParser {
using RawProjectTree = DataStructures::ProjectTree; //std::vector<File>;
using ParsedProjectTree = DataStructures::ParsedProjectTree; //std::vector<ParsedFile>;
const std::string initPath_;
const RawProjectTree rawData_;
const ParsedProjectTree product_;
public:
explicit ProjectTreeParser(const std::string& initPath, const RawProjectTree& rawData):
initPath_(initPath),
rawData_(rawData),
product_(BuildProduct())
{}
ParsedProjectTree getProduct() const { return product_; }
private:
ParsedProjectTree BuildProduct() const {
ParsedProjectTree result;
result.reserve(rawData_.size());
for (const auto& file : rawData_) {
FileParser parser(initPath_, file);
result.push_back(parser.getProduct());
}
return result;
}
};



############################################################################  source/Tools

tools/Converter.hpp
tools/FileIO.hpp
tools/IgnoreFiles.hpp




############################################################################
#pragma once
namespace Tools {
class Converter;
class FileIO;
class IgnoreFiles;
}



############################################################################  source/catch_main.cpp

plugins/catch.hpp




############################################################################
#define CATCH_CONFIG_MAIN



############################################################################  source/main.cpp
iostream

DataStructures
Program.hpp




############################################################################
int main(int argc, char* argv[]) {
PathInitializer target(argc, argv);
Program program(target.getPath());
program.execute();
std::cout << "\n\n";
return 0;
}
/* TODO:
- napisz obsługę flag. -md -markdown -txt -text
*/



############################################################################  source/dataStructures





############################################################################



############################################################################  source/dataStructures/BaseStructures
string
vector





############################################################################
#pragma once
namespace BaseStructures {
using Data = std::vector<std::string>;
using Line = std::string;
}



############################################################################  source/dataStructures/DataWithSyntax.hpp

BaseStructures




############################################################################
#pragma once
class DataWithSyntax {
using Line = BaseStructures::Line;
const std::string type_;
const Line data_;
public:
DataWithSyntax(const std::string& type, const Line& line):
type_(type),
data_(line)
{}
};



############################################################################  source/dataStructures/FileHeader.hpp
string
vector

PathInitializer.hpp




############################################################################
#pragma once
struct FileHeader {
std::string name_;
std::string path_;
std::string format_;
std::vector<FileHeader> subFiles_;
int depth_;
public:
explicit FileHeader(const std::string& path, const std::vector<FileHeader>& subFiles):
name_(path),
path_(),
format_(),
subFiles_(subFiles),
depth_()
{}
explicit FileHeader(
const std::string& name,
const std::string& path,
const std::string& format,
const std::vector<FileHeader>& subFiles,
const int depth):
name_(name),
path_(path),
format_(format),
subFiles_(subFiles),
depth_(depth)
{}
std::string getName() const { return name_; }
std::string getPath() const { return path_; }
std::string getFormat() const { return format_; }
std::string getFile() const { return path_ + name_ + format_; }
std::vector<FileHeader> getSubFiles() const { return subFiles_; }
bool isCatalog() const { return !subFiles_.empty(); }
};



############################################################################  source/dataStructures/ParsedFile.hpp
algorithm
string
vector

FileHeader.hpp
../Tools
BaseStructures




############################################################################
#pragma once
//#include "../DataStructures"
class ParsedFile : public FileHeader {
using Converter = Tools::Converter;
using Data = BaseStructures::Data; // std::vector<std::string>;
// using SyntaxedData = DataStructures::SyntaxedData;
Data data_;
// SyntaxedData syntaxedData_;
Data libIncludes_;
Data projIncludes_;
public:
explicit ParsedFile(const FileHeader& base, const Data& data,
/* const SyntaxedData& syntaxedData,*/ const Data& includes):
FileHeader(base),
data_(data),
//syntaxedData_(syntaxedData),
libIncludes_(),
projIncludes_()
{
BuildIncludes(includes);
}
std::string getData() const { return Converter::to_string(data_); }
std::vector<std::string> getLibIncludes() const { return libIncludes_; }
std::vector<std::string> getProjIncludes() const { return projIncludes_; }
private:
void BuildIncludes(const Data& includes) {
for (auto str : includes) {
str = Converter::removeWhitespaces(str);
if (str.at(0) == '<') {
libIncludes_.push_back(str.substr(1, str.length() - 2));
}
else if (str.at(0) == '\"') {
projIncludes_.push_back(str.substr(1, str.length() - 2));
}
else {
throw std::logic_error("ParsedFile::BuildIncludes(): wrong syntax \"" + str + "\"");
}
}
}
};



############################################################################  source/dataStructures/PathInitializer.ut.cpp

../plugins/catch.hpp
PathInitializer.ut.hpp




############################################################################
TEST_CASE("PathInitializer: static operations", "[CutoutName], [CutoutFormat], [AppendConditionalSlash]") {
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
WHEN("Testing the CutoutName()") {
struct test {
const PathInitializer_UnitTest object_;
const std::string expectedValue_;
std::string log() const {
return
"{ \"" + object_.getTestValue()
+ "\" == \"" + expectedValue_
+ "\" }";
}
};
const std::initializer_list<test> tests = {
{ PathInitializer_UnitTest("\n"), "\n" },
{ PathInitializer_UnitTest(""), "" },
{ PathInitializer_UnitTest("."), "." },
{ PathInitializer_UnitTest(".."), ".." },
{ PathInitializer_UnitTest("./"), "./" },
{ PathInitializer_UnitTest("../"), "../" },
{ PathInitializer_UnitTest("a."), "a" },
{ PathInitializer_UnitTest("a.abcd"), "a" },
{ PathInitializer_UnitTest("abcd."), "abcd" },
{ PathInitializer_UnitTest("abcd.abcd"), "abcd" },
{ PathInitializer_UnitTest(".a."), ".a" },
{ PathInitializer_UnitTest(".a.abcd"), ".a" },
{ PathInitializer_UnitTest(".abcd."), ".abcd" },
{ PathInitializer_UnitTest(".abcd.abcd"), ".abcd" },
{ PathInitializer_UnitTest("..a."), "." },
{ PathInitializer_UnitTest("..a.abcd"), "." },
{ PathInitializer_UnitTest("..abcd."), "." },
{ PathInitializer_UnitTest("..abcd.abcd"), "." }
};
for (const auto& test : tests) {
THEN(test.log()) {
REQUIRE_NOTHROW(test.object_.CutoutName());
auto result = test.object_.CutoutName();
REQUIRE(result == test.expectedValue_);
}
}
}
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
WHEN("Testing the CutoutFormat()") {
struct test {
const PathInitializer_UnitTest object_;
const std::string expectedValue_;
std::string log() const {
return
"{ \"" + object_.getTestValue()
+ "\" == \"" + expectedValue_
+ "\" }";
}
};
const std::initializer_list<test> tests = {
{ PathInitializer_UnitTest("\n"), "" },
{ PathInitializer_UnitTest(""), "" },
{ PathInitializer_UnitTest("."), "" },
{ PathInitializer_UnitTest(".."), "" },
{ PathInitializer_UnitTest("./"), "" },
{ PathInitializer_UnitTest("../"), "" },
{ PathInitializer_UnitTest("a."), "." },
{ PathInitializer_UnitTest("a.abcd"), ".abcd" },
{ PathInitializer_UnitTest("abcd."), "." },
{ PathInitializer_UnitTest("abcd.abcd"), ".abcd" },
{ PathInitializer_UnitTest(".a."), "." },
{ PathInitializer_UnitTest(".a.abcd"), ".abcd" },
{ PathInitializer_UnitTest(".abcd."), "." },
{ PathInitializer_UnitTest(".abcd.abcd"), ".abcd" },
{ PathInitializer_UnitTest("..a."), ".a." },
{ PathInitializer_UnitTest("..a.abcd"), ".a.abcd" },
{ PathInitializer_UnitTest("..abcd."), ".abcd." },
{ PathInitializer_UnitTest("..abcd.abcd"), ".abcd.abcd" }
};
for (const auto& test : tests) {
THEN(test.log()) {
REQUIRE_NOTHROW(test.object_.CutoutFormat());
auto result = test.object_.CutoutFormat();
REQUIRE(result == test.expectedValue_);
}
}
}
//_______________________________________________________________________________________________________
//-------------------------------------------------------------------------------------------------------
WHEN("Testing the AppendConditionalSlash()") {
struct test {
const PathInitializer_UnitTest object_;
const std::string expectedValue_;
std::string log() const {
return
"{ \"" + object_.getTestValue()
+ "\" == \"" + expectedValue_
+ "\" }";
}
};
const std::initializer_list<test> tests = {
{ PathInitializer_UnitTest("\n"), "\n/" },
{ PathInitializer_UnitTest(""), "" },
{ PathInitializer_UnitTest("."), "./" },
{ PathInitializer_UnitTest(".."), "../" },
{ PathInitializer_UnitTest("./"), "./" },
{ PathInitializer_UnitTest("../"), "../" },
{ PathInitializer_UnitTest("a."), "a./" },
{ PathInitializer_UnitTest("a.abcd"), "a.abcd/" },
{ PathInitializer_UnitTest(".abcd."), ".abcd./" },
{ PathInitializer_UnitTest("..abcd.abcd"), "..abcd.abcd/" },
{ PathInitializer_UnitTest("a./"), "a./" },
{ PathInitializer_UnitTest("a.abcd/"), "a.abcd/" },
{ PathInitializer_UnitTest(".abcd./"), ".abcd./" },
{ PathInitializer_UnitTest("..abcd.abcd/"), "..abcd.abcd/" },
{ PathInitializer_UnitTest("a.//"), "a.//" },
{ PathInitializer_UnitTest("a.abcd//"), "a.abcd//" },
{ PathInitializer_UnitTest(".abcd.//"), ".abcd.//" },
{ PathInitializer_UnitTest("..abcd.abcd//"), "..abcd.abcd//" }
};
for (const auto& test : tests) {
THEN(test.log()) {
REQUIRE_NOTHROW(test.object_.AppendConditionalSlash());
auto result = test.object_.AppendConditionalSlash();
REQUIRE(result == test.expectedValue_);
}
}
}
}



############################################################################  source/dataStructures/PathInitializer.ut.hpp
string

PathInitializer.hpp




############################################################################
#pragma once
class PathInitializer_UnitTest : PathInitializer {
const std::string testValue_;
public:
explicit PathInitializer_UnitTest(const std::string& testValue):
PathInitializer("",""),
testValue_(testValue)
{}
std::string getTestValue() const { return testValue_; }
std::string CutoutName() const {
return PathInitializer::CutoutName(testValue_);
}
std::string CutoutFormat() const {
return PathInitializer::CutoutFormat(testValue_);
}
std::string AppendConditionalSlash() const {
return PathInitializer::AppendConditionalSlash(testValue_);
}
};



############################################################################  source/dataStructures/PathInitializer.hpp
string

../Tools




############################################################################
#pragma once
class PathInitializer {
using IgnoreFiles = Tools::IgnoreFiles;
const std::string path_;
const std::string name_;
const std::string format_;
public:
explicit PathInitializer(const int& argc, const char* const * const argv):
path_(GenPath(argc, argv)),
name_(),
format_()
{}
explicit PathInitializer(const std::string& path, const std::string& fullName):
path_(AppendConditionalSlash(path)),
name_(CutoutName(fullName)),
format_(CutoutFormat(fullName))
{}
std::string getPath() const { return path_; }
std::string getName() const { return name_; }
std::string getFormat() const { return format_; }
std::string getDefaultPath() const { return "../"; }
private:
std::string GenPath(const int& argc, const char* const * const argv) const {
if (argc > 1) {
return AppendConditionalSlash(argv[1]);
}
return getDefaultPath();
}
protected:
static std::string CutoutName(const std::string& str) {
if (Tools::IgnoreFiles::isIgnored(str)) {
return str;
}
auto index = str.find('.', 1);
if (index == std::string::npos) {
return str;
}
index = str.size() - index;
std::string result;
result.insert(result.begin(), str.begin(), str.end()-index);
return result;
}
static std::string CutoutFormat(const std::string& str) {
if (Tools::IgnoreFiles::isIgnored(str)) {
return "";
}
auto index = str.find('.', 1);
if (index == std::string::npos) {
return "";
}
std::string result;
result.insert(result.begin(), str.begin()+index, str.end());
return result;
}
static std::string AppendConditionalSlash(std::string str) {
if (!str.empty()) {
str += (str.at(str.size()-1) == '/')? "" : "/";
}
return str;
}
};



############################################################################  source/tools





############################################################################



############################################################################  source/tools/Converter.hpp
algorithm
set
sstream
vector





############################################################################
#pragma once
namespace Tools {
class Converter {
public:
template <class T>
static std::set<T> to_set(const std::vector<T>& data) {
return std::set<T>(data.begin(), data.end());
}
static std::string to_fileData(const std::set<std::string>& data) {
std::string result;
std::for_each (data.begin(), data.end(), [&](const auto& val){result += val + '\n';});
return result;
}
static std::string to_string(const std::vector<std::string>& data2) {
std::stringstream result;
auto data = removeEmptyLines(data2);
std::for_each(data.begin(), data.end(), [&](const auto& line){result << removeWhitespaces(line) << "\n";});
return result.str();
}
static std::string removeWhitespaces(const std::string& data) {
std::string result = data;
result = RemoveSpecialChars(result);
result = RemoveFromBegin(result);
result = RemoveFromEnd(result);
result = RemoveAdjacentSpaces(result);
return result;
}
static std::vector<std::string> removeEmptyLines(const std::vector<std::string>& data) {
std::vector<std::string> result;
result.reserve(data.size());
for (auto record : data) {
record = removeWhitespaces(record);
if (!record.empty()) {
result.push_back(record);
}
}
return result;
}
private:
static std::string RemoveSpecialChars(const std::string& data) {
std::string result = data;
std::for_each(begin(result), end(result),
[](auto& ch){ ch = (ch == '\n' || ch == '\t')? ' ' : ch; });
return result;
}
static std::string RemoveFromBegin(const std::string& data) {
size_t i = 0;
for ( ; i < data.size(); ++i) {
if (data[i] != ' ') {
break;
}
}
return data.substr(i);
}
static std::string RemoveFromEnd(const std::string& data) {
int i = static_cast<int>(data.size()) - 1;
for ( ; i >= 0; --i) {
if (data[i] != ' ') {
break;
}
}
return data.substr(0, i+1);
}
static std::string RemoveAdjacentSpaces(const std::string& data) {
std::stringstream result;
bool foundSpace = false;
for (size_t i = 0; i < data.size(); ++i) {
if (!foundSpace) {
result << data[i];
foundSpace = (data[i] == ' ');
continue;
}
foundSpace = (data[i] == ' ');
if (!foundSpace) {
result << data[i];
}
}
return result.str();
}
};
} // namespace Tools



############################################################################  source/tools/FileIO.hpp
dirent.h
exception
fstream
string
vector

IgnoreFiles.hpp




############################################################################
#pragma once
namespace Tools {
class FileIO {
explicit FileIO() {}
public:
static bool fileExist(const std::string& path) {
std::ifstream readFile(path);
if (!readFile || !readFile.is_open()) {
readFile.close();
return false;
}
readFile.close();
return true;
}
static std::vector<std::string> readPaths(const std::string& targetPath) {
std::vector<std::string> result;
DIR* directory;
directory = opendir(targetPath.c_str());
if (!directory) {
return result;
}
struct dirent* entry;
while ((entry = readdir(directory)) != NULL) {
const std::string data = entry->d_name;
if (IgnoreFiles::isIgnored(data)) {
continue;
}
result.push_back(data);
}
closedir(directory);
return result;
}
static std::vector<std::string> readFile(const std::string& path) {
std::ifstream readFile(path);
if (!readFile || !readFile.is_open()) {
throw std::logic_error("Cannot read given file path: " + path + "\n");
}
std::vector<std::string> result;
std::string record;
while (std::getline(readFile, record)) {
result.push_back(record);
}
readFile.close();
return result;
}
static void saveToFile(const std::string& path, const std::string& data) {
std::ofstream output(path);
if (!output || !output.is_open()) {
throw std::logic_error("Cannot save to file: " + path + "\n");
}
output << data;
output.close();
}
};
} // namespace Tools



############################################################################  source/tools/IgnoreFiles.cpp
string
vector

IgnoreFiles.hpp




############################################################################
namespace Tools {
const std::string IgnoreFiles::filename_ = ".supignore";
const std::set<std::string> IgnoreFiles::formatIgnores_ {
".ut.cpp",
".ut.hpp"
};
const std::set<std::string> IgnoreFiles::alwaysIgnores_ {
"\n",
"",
".",
"..",
"./",
"../"
};
std::set<std::string> IgnoreFiles::defaultIgnores_ {
".git",
".gitignore",
".notes",
".sup",
"notes",
"build",
"plugins",
"tags",
"README.md",
"CMakeLists.txt"
};
} // namespace Tools



############################################################################  source/tools/IgnoreFiles.hpp
algorithm
set
string
vector





############################################################################
#pragma once
namespace Tools {
class IgnoreFiles {
const static std::string filename_;
const static std::set<std::string> alwaysIgnores_;
const static std::set<std::string> formatIgnores_;
static std::set<std::string> defaultIgnores_;
static std::set<std::string> ignored_;
explicit IgnoreFiles() { }
public:
static void setIgnoreFiles(const std::set<std::string>& data) { defaultIgnores_ = data; }
static std::string getIgnoreFileName() { return filename_; }
static std::set<std::string> getDefaultIgnoreFiles() { return defaultIgnores_; }
static bool isAlwaysIgnored(const std::string& value) {
return (alwaysIgnores_.find(value) != alwaysIgnores_.end());
}
static bool isFormatIgnored(const std::string& format) {
return (formatIgnores_.find(format) != formatIgnores_.end());
}
static bool isIgnored(const std::string& value) {
if (isAlwaysIgnored(value)) {
return true;
}
if (isFormatIgnored(value)) {
return true;
}
return (defaultIgnores_.find(value) != defaultIgnores_.end());
}
static std::vector<std::string> pickoutAlwaysIgnored(const std::vector<std::string>& vctr) {
std::vector<std::string> result;
result.resize(vctr.size());
std::copy_if(vctr.begin(), vctr.end(), result.begin(), [](auto val){return !isAlwaysIgnored(val);});
return result;
}
};
} // namespace Tools
