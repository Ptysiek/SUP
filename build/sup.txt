Author of SUP-SeeYourPoint: Kacu Kacper Kaleta [https://github.com/Ptysiek]
File generation date: Thu Jan 14 19:36:56 2021


_____________________________________________
Table of contents:   ------------------------
	[source]
	|	DirectoriesReader.hpp
	|	DocumentationGenerator.hpp
	|	File.hpp
	|	StateMachine.hpp
	|	catch_main.cpp
	|	main.cpp
	


class DirectoriesReader {
const static std::set<std::string> ignoreDirectories_;
explicit DirectoriesReader() { }
public:
static std::vector<File> getDirectories(const std::string& startpath) {
return GetDirectoriesRecursive(startpath);
}
private:
static std::vector<File> GetDirectoriesRecursive(std::string startpath) {
startpath = ConditionalSlashAppend(startpath);
auto directoryNames = ReadDirectories(startpath);
auto files = MakeFiles(directoryNames, startpath);
for (auto& file : files) {
auto subdirectories = GetDirectoriesRecursive(startpath + file.name_);
if (subdirectories.size() > 0) {
file.isCatalog_ = true;
file.files_ = subdirectories;
}
}
return files;
}
static std::vector<File> MakeFiles(
const std::vector<std::string>& directoryNames, 
const std::string& startpath) 
{
std::vector<File> files;
for (const auto& dirname : directoryNames) {
files.push_back(File(dirname, ConditionalSlashAppend(startpath))); 
}
return files;
}
static std::string ConditionalSlashAppend(const std::string& startpath) {
if (size_t size = startpath.size(); size > 0) {
return (startpath[size-1] == '/')? startpath : startpath + '/';
}
return "";
}
static std::vector<std::string> ReadDirectories(const std::string& path) {
std::vector<std::string> directoryNames;
DIR* directory;
directory = opendir(path.c_str());
if (!directory) {
return directoryNames;
}
struct dirent* entry;
while ((entry = readdir(directory)) != NULL) {
std::string data = entry->d_name;
if (IgnoreListContains(data)) {
continue;
}
directoryNames.push_back(data);
}
closedir(directory);
return directoryNames;
}
static bool IgnoreListContains(const std::string& data) {
return (ignoreDirectories_.find(data) != ignoreDirectories_.end());
for (const auto& record : ignoreDirectories_) {
if (data == record) {
return false;
}
}
return true;
}
};
const std::set<std::string> DirectoriesReader::ignoreDirectories_ {
"\n",
"",
" ",
".",
"..",
".git",
".gitignore",
".notes",
"notes",
"build",
"tools",
"tags",
"README.md",
"CMakeLists.txt"
};
------------------------
------------------------




class DocumentationGenerator {
using ProjectMap = std::vector<std::string>;
const std::string startPath_;
const std::string filename_;
std::vector<File> directories_;
public:
DocumentationGenerator(const std::string& startPath):
startPath_(startPath),
filename_("sup.txt")
{}
void setDirectoriesVector(std::vector<File>& vctr) {
directories_ = vctr;
sortDirectories(directories_);
}
void sortDirectories(std::vector<File>& directories) {
std::sort(directories.begin(), directories.end(), SortCriterion);
for (auto& subDir : directories) {
if (subDir.isCatalog_) {
sortDirectories(subDir.files_);
}
}
}
static bool SortCriterion(const File& f, const File& s) { 
int test = f.isCatalog_ + s.isCatalog_;
if (test % 2 == 0) {
return SecondSortCriterion_Alphabetical(f.name_, s.name_);
}
else {
return s.isCatalog_;
}
}
static bool SecondSortCriterion_Alphabetical(const std::string& f, const std::string& s) { 
return (f < s);
}
bool generate() {
std::string data = "";
data += getHeader();
data += "File generation date: " + getDate();
data += "\n\n";
data += "_____________________________________________\n";
data += "Table of contents:   ------------------------\n";
data += getTableOfContents(directories_);
auto dirs = getDirectories(directories_);
std::map<std::string,std::string> allFilesData;
for (const auto& file : dirs) {
auto fileData_tmp = readFromFile(startPath_ + file);
allFilesData[file] = fileData_tmp; 
}
StateMachine sm;
data += sm.Process(allFilesData);
std::ofstream output(filename_);
if (!output || !output.is_open()) {
return false;
}
output << data;
output.close();
return true;
}
private:
std::string readFromFile(const std::string& path) {
std::string fileData = "";
std::ifstream readFile(path);
std::string tmp;
while (std::getline(readFile, tmp)) {
if (tmp == "\n" || tmp == "") {
continue;
}
fileData += tmp;
fileData += "\n";
}
readFile.close();
return fileData;
}
std::string getHeader() {
return "Author of SUP-SeeYourPoint: Kacu Kacper Kaleta [https:
}
std::string getDate() {
using TimePoint = std::chrono::time_point<std::chrono::system_clock>;
TimePoint thisPoint = std::chrono::system_clock::now();
std::time_t t = std::chrono::system_clock::to_time_t(thisPoint);
std::string date = std::ctime(&t);
return date;
}
std::string getTableOfContents(std::vector<File> directories, size_t tab=1) {
if (directories.size() < 1) {
throw std::logic_error("DocumentationGenerator::getTableOfContents()");
}
std::string result = "";
for (const auto& file : directories) {
result += getTabs(tab);
if (file.isCatalog_) {
result += "[";
result += file.name_;
result += "]\n";
result += getTableOfContents(file.files_, tab + 1);   
result += getTabs(tab);
}
else {
result += file.name_;
}
result += "\n";
}
return result;
}
std::string getTabs(size_t tab=1) {
std::string result = "\t";
for (size_t i = 1; i < tab; ++i) {
result += "|\t";
}
return result;
}
std::vector<std::string> getDirectories(const std::vector<File>& directories, const std::string& path="") {
std::vector<std::string> result;
for (const auto& file : directories) {
if (file.isCatalog_) {
auto subFiles = getDirectories(file.files_, path + file.name_ + "/");
result.insert(result.end(), subFiles.begin(), subFiles.end() );
}
else {
result.push_back(path + file.name_);
}
}
return result;
}
};
------------------------
------------------------




struct File {
bool isCatalog_;
std::string name_;
std::string path_;
std::string fullname_;
std::vector<File> files_; 
explicit File(const std::string& name, const std::string& path): 
isCatalog_(false),
name_(name),
path_(path),
fullname_(name+path)
{}
};
------------------------
------------------------




struct Node {
explicit Node(
const std::string& originFile, 
const std::string& name,
const std::string& fullName) :
originFile_(originFile),
name_(name),
fullName_(fullName)
{}
const std::string originFile_;
const std::string name_;
const std::string fullName_;
std::string type_;
std::vector<std::shared_ptr<Node>> nodes_;
};
class StateMachine {
std::vector<Node> collectiveData;
size_t index_;
std::string processedFileData_;
bool is_multilineComment_;
std::vector<std::string> connectedDirs_;
public:
std::string Process(const std::map<std::string,std::string> allFilesData) {
std::string result = "";
for (const auto& [fileName, fileData] : allFilesData) {
result += "\n\n";
result += ProcessNewFile(fileName, fileData);
result += "------------------------\n";
for (const auto& record : connectedDirs_) {
result += record + "\n";
}
result += "------------------------\n";
result += "\n\n";
}
return result;
}
private:
void initMachine(std::string fileData) {
index_ = 0;
processedFileData_ = fileData;
is_multilineComment_ = false;
connectedDirs_.clear();
}
std::string ProcessNewFile(const std::string& fileName, const std::string& fileData) {
initMachine(fileData);
std::string result = "";
std::string fullNameEntry = "";
Node test (fileName, "class", fullNameEntry + "class");
while (index_ < processedFileData_.size()) {
std::string oneLine = ReadOneLine();
oneLine = StripFromComments(oneLine);
oneLine = StripFromExtraWhiteSpaces(oneLine);
oneLine = StripFromDirectives(oneLine);
if (oneLine != "" && oneLine != "\n") {
result += oneLine + '\n';
}
}
for (const auto& character : fileData) {
if (character != ' ') {
}
}
return result;
}
std::string ReadOneLine() {
std::string result = "";
for ( ; index_ < processedFileData_.size(); ++index_) {
const char character = processedFileData_[index_];
if (character == '\n') {
++index_;
return result;
}
result += character;
}
return result;
}
std::string StripFromDirectives(const std::string& oneLine) {
if (oneLine[0] != '#') {
return oneLine;
}
size_t k = 0;
const std::string code = "include";
size_t i = 1;
for ( ; i < oneLine.size() && k < code.size(); ++i) {
if (oneLine[i] != code[k] && oneLine[i] != ' ') {
return "";
}
else if (oneLine[i] == code[k]) {
++k;
}
}
++i;
for ( ; i < oneLine.size(); ++i) {
if (oneLine[i] != '"' && oneLine[i] != '\"' && oneLine[i] != '<' && oneLine[i] != ' ') {
return "";
}
}
std::string directory = "sup";
for ( ; i < oneLine.size(); ++i) {
if (oneLine[i] == '"' && oneLine[i] == '\"' && oneLine[i] == '>') {
break;
}
directory += oneLine[i];
}
connectedDirs_.push_back(directory);
return "";
}
std::string StripFromExtraWhiteSpaces(const std::string& oneLine) {
std::string result = "";
size_t i = 0;
for ( ; i < oneLine.size(); ++i) {
if (oneLine[i] != ' ' && oneLine[i] != '\n' && oneLine[i] != '\t') {
break;
}
}
for ( ; i < oneLine.size(); ++i) {
result += oneLine[i];
}
return result;
}
std::string StripFromComments(const std::string& oneLine) {
std::string result = "";
bool lastCharacter = true;
size_t i = 1;
while (i < oneLine.size()) {
if (is_multilineComment_) {
if (oneLine[i-1] == '*' && oneLine[i] == '/') {
is_multilineComment_ = false;
lastCharacter = false;
}
}
else {
if (oneLine[i-1] == '/' && oneLine[i] == '/') {
return result;
}
if (oneLine[i-1] == '/' && oneLine[i] == '*') {
is_multilineComment_ = true;
++i;
continue;
}
lastCharacter = true;
result += oneLine[i-1];
}
++i;
}
if (!is_multilineComment_ && lastCharacter && i == oneLine.size()) {
result += oneLine[i-1];
}
return result;
}
};
------------------------
------------------------




------------------------
------------------------




int main() {
const std::string startPath = "../"; 
DocumentationGenerator dgenerator(startPath);
auto getstuff = DirectoriesReader::getDirectories(startPath);
dgenerator.setDirectoriesVector(getstuff);
dgenerator.generate();
return 0;
}
------------------------
------------------------


